{"name":"Osxcollector","tagline":"A forensic evidence collection & analysis toolkit for OSX","body":"[![Build Status](https://travis-ci.org/Yelp/osxcollector.svg)](https://travis-ci.org/Yelp/osxcollector)\r\n\r\n# OSXCollector Manual\r\nOSXCollector is a forensic evidence collection & analysis toolkit for OSX.\r\n\r\n#### Forensic Collection\r\nThe collection script runs on a potentially infected machine and outputs a JSON file that describes the target machine. OSXCollector gathers information from plists, SQLite databases and the local file system.\r\n\r\n#### Forensic Analysis\r\nArmed with the forensic collection, an analyst can answer the question like:\r\n* _Is this machine infected?_\r\n* _How'd that malware get there?_\r\n* _How can I prevent and detect further infection?_\r\n\r\nYelp automates the analysis of most OSXCollector runs converting OSXCollector output into an easily readable and actionable summary of _just the suspicious stuff_.\r\n\r\n## Performing Collection\r\n`osxcollector.py` is a single Python file that runs without any dependencies on a standard OSX machine. This makes it really easy to run collection on any machine - no fussing with brew, pip, config files, or environment variables. Just copy the single file onto the machine and run it.\r\n\r\n\r\n`sudo osxcollector.py` is all it takes.\r\n\r\n```shell\r\n$ sudo osxcollector.py\r\nWrote 35394 lines.\r\nOutput in osxcollect-2014_12_21-08_49_39.tar.gz\r\n```\r\n\r\nThe JSON output of the collector, along with some helpful files like system logs, has been bundled into a .tar.gz for hand-off to an analyst.\r\n\r\n`osxcollector.py` also has a lot of useful options to change how collection works:\r\n* `-i INCIDENT_PREFIX`/`--id=INCIDENT_PREFIX`:\r\n  Sets an identifier which is used as the prefix of the output file. The default value is `osxcollect`.\r\n  ```shell\r\n  $ sudo osxcollector.py -i IncontinentSealord\r\n  Wrote 35394 lines.\r\n  Output in IncontinentSealord-2014_12_21-08_49_39.tar.gz\r\n  ```\r\n  Get creative with incident names, it makes it easier to laugh through the pain.\r\n\r\n* `-p ROOTPATH`/`--path=ROOTPATH`:\r\n  Sets the path to the root of the filesystem to run collection on. The default value is `/`. This is great for running collection on the image of a disk.\r\n  ```shell\r\n  $ sudo osxcollector.py -p '/mnt/powned'\r\n  ```\r\n\r\n* `-s SECTION`/`--section=SECTION`:\r\n  Runs only a portion of the full collection. Can be specified more than once. The full list of sections is:\r\n  * `version`\r\n  * `system_info`\r\n  * `kext`\r\n  * `startup`\r\n  * `applications`\r\n  * `quarantines`\r\n  * `downloads`\r\n  * `chrome`\r\n  * `firefox`\r\n  * `safari`\r\n  * `accounts`\r\n  * `mail`\r\n  * `full_hash`\r\n\r\n  ```shell\r\n  $ sudo osxcollector.py -s 'startup' -s 'downloads'\r\n  ```\r\n\r\n* `-d`/`--debug`:\r\n  Enables verbose output and python breakpoints. If something is wrong with OSXCollector, try this.\r\n\r\n  ```shell\r\n  $ sudo osxcollector.py -d\r\n  ```\r\n\r\n## Details of Collection\r\nThe collector outputs a `.tar.gz` containing all the collected artifacts. The archive contains a JSON file with the majority of information.  Additionally, a set of useful logs from the target system logs are included.\r\n\r\n#### Common Keys\r\n\r\n##### Every Record\r\nEach line of the JSON file records 1 _piece of information_.  There are some common keys that appear in every JSON record:\r\n* `osxcollector_incident_id`: A unique ID shared by every record.\r\n* `osxcollector_section`: The _section_ or type of data this record holds.\r\n* `osxcollector_subsection`: The _subsection_ or more detailed descriptor of the type of data this record holds.\r\n\r\n##### File Records\r\nFor records representing files there are a bunch of useful keys:\r\n* `ctime`: The file creation time.\r\n* `mtime`: The file modified time.\r\n* `file_path`: The absolute path to the file.\r\n* `md5`: MD5 hash of the file contents.\r\n* `sha1`: SHA1 hash of the file contents.\r\n* `sha2`: SHA2 hash of the file contents.\r\n* `signature_chain`: The common names of the certs in the file's signing chain\r\n\r\nFor records representing downloaded files:\r\n* `xattr-wherefrom`: A list containing the source and referrer URLs for the downloaded file.\r\n* `xattr-quarantines`: A string describing which application downloaded the file.\r\n\r\n##### SQLite Records\r\nFor records representing a row of a SQLite database:\r\n* `osxcollector_table_name`: The table name the row comes from.\r\n* `osxcollector_db_path`: The absolute path to the SQLite file.\r\n\r\nFor records that represent data associated with a specific user:\r\n* `osxcollector_username`: The name of the user\r\n\r\n#### Timestamps\r\nOSXCollector attempts to convert timestamps to human readable date/time strings in the format `YYYY-mm-dd hh:MM:ss`. It uses heuristics to automatically identify various timestamps:\r\n* seconds since epoch\r\n* milliseconds since epoch\r\n* seconds since 2001-01-01\r\n* seconds since 1601-01-01\r\n\r\n#### Sections\r\n##### `version` section\r\n\r\nThe current version of OSXCollector.\r\n\r\n##### `system_info` section\r\n\r\nCollects basic information about the system:\r\n\r\n - system name\r\n - node name\r\n - release\r\n - version\r\n - machine\r\n\r\n##### `kext` section\r\n\r\nCollects the Kernel extensions from:\r\n- `/System/Library/Extensions`\r\n- `/Library/Extensions`\r\n\r\n##### `startup` section\r\n\r\nCollects information about the\r\n[LaunchAgents](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man5/launchd.plist.5.html),\r\nLaunchDaemons, ScriptingAdditions,\r\n[StartupItems](https://developer.apple.com/library/mac/documentation/macosx/conceptual/bpsystemstartup/chapters/StartupItems.html)\r\nand other login items from:\r\n\r\n - `/System/Library/LaunchAgents`\r\n - `/System/Library/LaunchDaemons`\r\n - `/Library/LaunchAgents`\r\n - `~/Library/LaunchAgents`\r\n - `/Library/LaunchDaemons`\r\n - `/System/Library/ScriptingAdditions`\r\n - `/Library/ScriptingAdditions`\r\n - `/System/Library/StartupItems`\r\n - `/Library/StartupItems`\r\n - `~/Library/Preferences/com.apple.loginitems.plist`\r\n\r\nMore information about the Max OS X startup can be found here:\r\nhttp://www.malicious-streams.com/article/Mac_OSX_Startup.pdf\r\n\r\n##### `applications` section\r\n\r\nHashes installed applications and gathers install history from:\r\n\r\n - `/Applications`\r\n - `~/Applications`\r\n - `/Library/Receipts/InstallHistory.plist`\r\n\r\n##### `quarantines` section\r\n\r\nQuarantines are basically the info necessary to show the 'Are you sure you wanna run this?' when a user is trying to open a file downloaded from the Internet.\r\nFor some more details, checkout the Apple Support explanation of Quarantines:\r\nhttp://support.apple.com/kb/HT3662\r\n\r\nThis section collects also information from XProtect hash-based malware check\r\nfor quarantines files. The plist is at:\r\n`/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/XProtect.plist`\r\n\r\nXProtect also add minimum versions for Internet Plugins. That plist is at:\r\n`/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/XProtect.meta.plist`\r\n\r\n##### `downloads` section\r\n\r\nHashes all users' downloaded files from:\r\n\r\n - `~/Downloads`\r\n - `~/Library/Mail Downloads`\r\n - `~/Library/Containers/com.apple.mail/Data/Library/Mail Downloads`\r\n\r\n##### `chrome` section\r\n\r\nCollects following information from Google Chrome web browser:\r\n\r\n - History\r\n - Archived History\r\n - Cookies\r\n - Login Data\r\n - Top Sites\r\n - Web Data\r\n\r\nThis data is extracted from `~/Library/Application Support/Google/Chrome/Default`\r\n\r\n##### `firefox` section\r\n\r\nCollects information from the different SQLite databases in a Firefox profile:\r\n\r\n - Cookies\r\n - Downloads\r\n - Form History\r\n - History\r\n - Signons\r\n - Permissions\r\n - Addons\r\n - Extension\r\n - Content Preferences\r\n - Health Report\r\n - Webapps Store\r\n\r\nThis information is extracted from `~/Library/Application Support/Firefox/Profiles`\r\n\r\nFor more details about Firefox profile folder see\r\nhttp://kb.mozillazine.org/Profile_folder_-_Firefox\r\n\r\n##### `safari` section\r\n\r\nCollects information from the different plist and SQLite databases in a Safari\r\nprofile:\r\n\r\n - Downloads\r\n - History\r\n - Databases\r\n - Local Storage\r\n\r\n##### `accounts` section\r\nCollects information about users' accounts:\r\n\r\n - system admins: `/private/var/db/dslocal/nodes/Default/groups/admin.plist`\r\n - system users: `/private/var/db/dslocal/nodes/Default/users`\r\n - social accounts: `~/Library/Accounts/Accounts3.sqlite`\r\n - users' recent items: `~/Library/Preferences/com.apple.recentitems.plist`\r\n\r\n##### `mail` section\r\nHashes files in the mail app directories:\r\n\r\n - `~/Library/Mail`\r\n - `~/Library/Mail Downloads`\r\n\r\n##### `full_hash` section\r\nHashes all the files on disk. All of 'em. This does not run by default. It must be triggered with:\r\n```shell\r\n$ sudo osxcollector.py -s full_hash\r\n```\r\n\r\n## Basic Manual Analysis\r\nForensic analysis is a bit of art and a bit of science. Every analyst will see a bit of a different story when reading the output from OSXCollector. That's part of what makes analysis fun.\r\n\r\nGenerally, collection is performed on a target machine because something is hinky: anti-virus found a file it doesn't like, deep packet inspect observed a callout, endpoint monitoring noticed a new startup item. The details of this initial alert - a file path, a timestamp, a hash, a domain, an IP, etc. - that's enough to get going.\r\n\r\n#### Timestamps\r\nSimply greping a few minutes before and after a timestamp works great:\r\n\r\n```shell\r\n$ cat INCIDENT32.json | grep '2014-01-01 11:3[2-8]'\r\n```\r\n\r\n#### Browser History\r\nIt's in there. A tool like [jq](http://stedolan.github.io/jq/) can be very helpful to do some fancy output:\r\n\r\n```shell\r\n$ cat INCIDENT32.json | grep '2014-01-01 11:3[2-8]' | jq 'select(has(\"url\"))|.url'\r\n```\r\n\r\n#### A Single User\r\n```shell\r\n$ cat INCIDENT32.json | jq 'select(.osxcollector_username==\"ivanlei\")|.'\r\n```\r\n\r\n## Automated Analysis\r\nThe `osxcollector.output_filters` package contains filters that process and transform the output of OSXCollector. The goal of filters is to make it easy to analyze OSXCollector output.\r\n\r\nEach filter has a single purpose. They do one thing and they do it right.\r\n\r\n#### Running Filters in a VirtualEnv\r\nUnlike `osxcollector.py` filters have dependencies that aren't already installed on a new Mac. The best solution for ensure dependencies can be found is to use virtualenv.\r\n\r\nTo setup a virtualenv for the first time use:\r\n```shell\r\n$ sudo pip install virtualenv\r\n$ virtualenv --system-site-packages venv_osxcollector\r\n$ source ./venv_osxcollector/bin/activate\r\n$ pip install -r ./requirements-dev.txt\r\n```\r\n\r\n#### Filter Configuration\r\nMany filters require configuration, like API keys or details on a blacklist. The configuration for filters is done in a YAML file. The file is named `osxcollector.yaml`. The filter will look for the config file in:\r\n- The current directory.\r\n- The user's home directory\r\n- The path pointed to by the environment variable OSXCOLLECTOR_CONF\r\n\r\nA sample config is included. Make a copy and then modify if for yourself:\r\n```shell\r\n$ cp osxcollector.yaml.example osxcollector.yaml\r\n$ emacs osxcollector.yaml\r\n```\r\n\r\n#### Basic Filters\r\nUsing combinations of these basic filters, an analyst can figure out a lot of what happened without expensive tools, without threat feeds or fancy APIs.\r\n\r\n##### FindDomainsFilter\r\n`osxcollector.output_filters.find_domains.FindDomainsFilter` attempts to find domain names in OSXCollector output. The domains are added to the line with the key `osxcollector_domains`.\r\n\r\nFindDomainsFilter isn't too useful on it's own but it's super powerful when chained with filters like `FindBlacklistedFilter` and or `osxcollector.output_filters.virustotal.lookup_domains.LookupDomainsFilter`.\r\n\r\nTo run and see lines where domains have been added try:\r\n```shell\r\n$ python -m osxcollector.output_filters.find_domains -i RomeoCredible.json | \\\r\n    jq 'select(has(\"osxcollector_domains\"))'\r\n```\r\n\r\nUsage:\r\n```shell\r\n$ python -m osxcollector.output_filters.find_domains -h\r\nusage: find_domains.py [-h] [--input-file INPUT_FILE]\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  --input-file INPUT_FILE\r\n                        [OPTIONAL] Path to OSXCollector output to read.\r\n                        Defaults to stdin otherwise.\r\n```\r\n\r\n##### FindBlacklistedFilter\r\n`osxcollector.output_filters.find_blacklisted.FindBlacklistedFilter` reads a set of blacklists from the `osxcollector.yaml` and marks any lines with values on the blacklist. The BlacklistFilter is flexible and allows you to compare the OSXCollector output against multiple blacklists.\r\n\r\nYou _really should_ create blacklists for domains, file hashes, file names, and any known hinky stuff.\r\n\r\nConfiguration Keys:\r\n* `blacklist_name`: [REQUIRED] the name of the blacklist.\r\n* `blacklist_keys`: [REQUIRED] get the value of these keys and compare against the blacklist. These can be of the form `a.b` to look at `b` in `{\"a\": {\"b\": \"foo\"}}`\r\n* `blacklist_file_path`: [REQUIRED] path to a file with the actual values to blacklist\r\n* `blacklist_is_regex`: [REQUIRED] should the values in the blacklist file be treated as regex\r\n* `blacklist_is_domains`: [OPTIONAL] interpret values as domains and do some smart regex and subdomain stuff with them.\r\n\r\nIf you want to find blacklisted domains, you will have to use the find_domains filter to pull the domains out first. To see lines matching a specific blacklist named `domains` try:\r\n```shell\r\n$ python -m osxcollector.output_filters.find_domains -i RiddlerBelize.json | \\\r\n    python -m osxcollector.output_filters.find_blacklisted | \\\r\n    jq 'select(has(\"osxcollector_blacklist\")) | \\\r\n        select(.osxcollector_blacklist | keys[] | contains(\"domains\"))'\r\n```\r\n\r\nUsage:\r\n```shell\r\n$ python -m osxcollector.output_filters.find_blacklisted -h\r\nusage: find_blacklisted.py [-h] [--input-file INPUT_FILE]\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  --input-file INPUT_FILE\r\n                        [OPTIONAL] Path to OSXCollector output to read.\r\n                        Defaults to stdin otherwise.\r\n```\r\n\r\n##### RelatedFilesFilter\r\n`osxcollector.output_filters.related_files.RelatedFilesFilter` takes an initial set of file paths, names, or terms. It breaks this input into individual file and directory names and then searches for these terms across the entire OSXCollector output. The filter is smart and ignores common terms like `bin` or `Library` as well as ignoring user names.\r\n\r\nThis filter is great for figuring out how `evil_invoice.pdf` landed up on a machine. It'll find browser history, quarantines, email messages, etc. related to a file.\r\n\r\nTo run and see related lines try:\r\n```shell\r\n$ python -m osxcollector.output_filters.related_files -i CanisAsp.json -f '/foo/bar/baz' -f 'dingle' | \\\r\n    jq 'select(has(\"osxcollector_related\")) | \\\r\n        select(.osxcollector_related | keys[] | contains(\"files\"))'\r\n```\r\n\r\nUsage:\r\n```shell\r\n$ python -m osxcollector.output_filters.related_files -h\r\nusage: related_files.py [-h] [-f FILE_TERMS] [--input-file INPUT_FILE]\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  --input-file INPUT_FILE\r\n                        [OPTIONAL] Path to OSXCollector output to read.\r\n                        Defaults to stdin otherwise.\r\n\r\nRelatedFilesFilter:\r\n  -f FILE_TERMS, --file-term FILE_TERMS\r\n                        [OPTIONAL] Suspicious terms to use in pivoting through\r\n                        file names. May be specified more than once.\r\n```\r\n\r\n##### ChromeHistoryFilter\r\n`osxcollector.output_filters.chrome.sort_history.SortHistoryFilter` builds a really nice Chrome browser history sorted in descending time order. This output is comparable to looking at the history tab in the browser but actually contains _more_ info. The `core_transition` and `page_transition` keys explain whether the user got to the page by clicking a link, through a redirect, a hidden iframe, etc.\r\n\r\nTo run and see Chrome browser history:\r\n```shell\r\n$ python -m osxcollector.output_filters.chrome.sort_history -i SirCray.json | \\\r\n    jq 'select(.osxcollector_browser_history==\"chrome\")'\r\n```\r\n\r\nThis is great mixed with a grep in a certain time window, like maybe the 5 minutes before that hinky download happened.\r\n```shell\r\n$ python -m osxcollector.output_filters.chrome.sort_history -i SirCray.json | \\\r\n    jq -c 'select(.osxcollector_browser_history==\"chrome\")' | \\\r\n    egrep '2015-02-02 20:3[2-6]'\r\n```\r\n\r\nUsage:\r\n```shell\r\n$ python -m osxcollector.output_filters.chrome.sort_history -h\r\nusage: sort_history.py [-h] [--input-file INPUT_FILE]\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  --input-file INPUT_FILE\r\n                        [OPTIONAL] Path to OSXCollector output to read.\r\n                        Defaults to stdin otherwise.\r\n```\r\n\r\n##### FirefoxHistoryFilter\r\n`osxcollector.output_filters.firefox.sort_history.SortHistoryFilter` builds a really nice Firefox browser history sorted in descending time order. It's a lot like the `ChromeHistoryFilter`.\r\n\r\nTo run and see Firefox browser history:\r\n```shell\r\n$ python -m osxcollector.output_filters.firefox.sort_history -i CousingLobe.json | \\\r\n    jq 'select(.osxcollector_browser_history==\"firefox\")'\r\n```\r\n\r\nUsage:\r\n```shell\r\n$ python -m osxcollector.output_filters.firefox.sort_history -h\r\nusage: sort_history.py [-h] [--input-file INPUT_FILE]\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  --input-file INPUT_FILE\r\n                        [OPTIONAL] Path to OSXCollector output to read.\r\n                        Defaults to stdin otherwise.\r\n```\r\n\r\n##### ChromeExtensionsFilter\r\n`osxcollector.output_filters.chrome.find_extensions.FindExtensionsFilter` looks for extensions in the Chrome JSON files.\r\n\r\nTo run and see Chrome extensions:\r\n```shell\r\n$ python -m osxcollector.output_filters.chrome.find_extensions -i MotherlyWolf.json | \\\r\n    jq 'select(.osxcollector_section==\"chrome\" and\r\n               .osxcollector_subsection==\"extensions\")'\r\n```\r\n\r\nUsage:\r\n```shell\r\n$ python -m osxcollector.output_filters.chrome.find_extensions -h\r\nusage: find_extensions.py [-h] [--input-file INPUT_FILE]\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  --input-file INPUT_FILE\r\n                        [OPTIONAL] Path to OSXCollector output to read.\r\n                        Defaults to stdin otherwise.\r\n```\r\n\r\n##### FirefoxExtensionsFilter\r\n`osxcollector.output_filters.firefox.find_extensions.FindExtensionsFilter` looks for extensions in the Firefox JSON files.\r\n\r\nTo run and see Firefox extensions:\r\n```shell\r\n$ python -m osxcollector.output_filters.firefox.find_extensions -i FlawlessPelican.json | \\\r\n    jq 'select(.osxcollector_section==\"firefox\" and\r\n               .osxcollector_subsection==\"extensions\")'\r\n```\r\n\r\nUsage:\r\n```shell\r\n$ python -m osxcollector.output_filters.firefox.find_extensions -h\r\nusage: find_extensions.py [-h] [--input-file INPUT_FILE]\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  --input-file INPUT_FILE\r\n                        [OPTIONAL] Path to OSXCollector output to read.\r\n                        Defaults to stdin otherwise.\r\n```\r\n\r\n#### Threat API Filters\r\nBy taking the output of OSXCollector and looking up further info with OpenDNS and VirusTotal APIs, Yelp enhances the output with useful info. Some of these APIs aren't free but they are useful.\r\n\r\nUsing these filters as examples, it would be possible to integrate with additional free or premium threat APIs. `osxcollector.output_filters.base_filters.threat_feed.ThreatFeedFilter` has most of the plumbing for hooking up to arbitrary APIs.\r\n\r\n##### OpenDNS RelatedDomainsFilter\r\n`osxcollector.output_filters.opendns.related_domains.RelatedDomainsFilter` takes an initial set of domains and IPs and then looks up domains related to them with the OpenDNS Umbrella API.\r\n\r\nOften an initial alert contains a domain or IP your analysts don't know anything about. However, by gathering the 2nd generation related domains, familiar _friends_ might appear. When you're lucky, those related domains land up being the download source for some downloads you might have overlooked.\r\n\r\nThe filter will ignore domains if they are in the blacklist named `domain_whitelist`. This helps to reduce churn and false positives.\r\n\r\nRun it as and see what it found:\r\n```shell\r\n$ python -m osxcollector.output_filters.find_domains -i NotchCherry.json | \\\r\n    python -m osxcollector.output_filters.opendns.related_domains \\\r\n           -d dismalhedgehog.com -d fantasticrabbit.org \\\r\n           -i 128.128.128.28 | \\\r\n    jq 'select(has(\"osxcollector_related\")) |\r\n        select(.osxcollector_related | keys[] | contains(\"domains\"))'\r\n```\r\n\r\nThe results will look something like:\r\n```\r\n{\r\n   'osxcollector_related': {\r\n       'domains': {\r\n           'domain_in_line.com': ['dismalhedgehog.com'],\r\n           'another.com': ['128.128.128.28']\r\n       }\r\n    }\r\n}\r\n```\r\n\r\nUsage:\r\n```shell\r\n$ python -m osxcollector.output_filters.opendns.related_domains -h\r\nusage: related_domains.py [-h] [-d INITIAL_DOMAINS] [-i INITIAL_IPS]\r\n                          [--related-domains-generations GENERATIONS]\r\n                          [--input-file INPUT_FILE]\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  --input-file INPUT_FILE\r\n                        [OPTIONAL] Path to OSXCollector output to read.\r\n                        Defaults to stdin otherwise.\r\n\r\nopendns.RelatedDomainsFilter:\r\n  -d INITIAL_DOMAINS, --domain INITIAL_DOMAINS\r\n                        [OPTIONAL] Suspicious domains to use in pivoting. May\r\n                        be specified more than once.\r\n  -i INITIAL_IPS, --ip INITIAL_IPS\r\n                        [OPTIONAL] Suspicious IP to use in pivoting. May be\r\n                        specified more than once.\r\n  --related-domains-generations GENERATIONS\r\n                        [OPTIONAL] How many generations of related domains to\r\n                        lookup with OpenDNS\r\n```\r\n\r\n##### OpenDNS LookupDomainsFilter\r\n`osxcollector.output_filters.opendns.lookup_domains.LookupDomainsFilter` lookups domain reputation and threat information with the OpenDNS Umbrella API. It adds information about _suspicious_ domains to the output lines.\r\n\r\nThe filter uses a heuristic to determine what is _suspicious_. It can create false positives but usually a download from a domain marked as _suspicious_ is a good lead.\r\n\r\nRun it and see what was found:\r\n```shell\r\n$ python -m osxcollector.output_filters.find_domains -i GladElegant.json | \\\r\n    python -m osxcollector.output_filters.opendns.lookup_domains | \\\r\n    jq 'select(has(\"osxcollector_opendns\"))'\r\n```\r\n\r\nUsage:\r\n```shell\r\n$ python -m osxcollector.output_filters.opendns.lookup_domains -h\r\nusage: lookup_domains.py [-h] [--input-file INPUT_FILE]\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  --input-file INPUT_FILE\r\n                        [OPTIONAL] Path to OSXCollector output to read.\r\n                        Defaults to stdin otherwise.\r\n```\r\n\r\n##### VirusTotal LookupDomainsFilter\r\n`osxcollector.output_filters.virustotal.lookup_domains.LookupDomainsFilter` lookups domain reputation and threat information with the VirusTotal API. It adds information about _suspicious_ domains to the output lines. It's a lot like the OpenDNS filter of the same name.\r\n\r\nThe filter uses a heuristic to determine what is _suspicious_. It can create a lot of false positives but also provides good leads.\r\n\r\nRun it and see what was found:\r\n```shell\r\n$ python -m osxcollector.output_filters.find_domains -i PippinNightstar.json | \\\r\n    python -m osxcollector.output_filters.virustotal.lookup_domains | \\\r\n    jq 'select(has(\"osxcollector_vtdomain\"))'\r\n```\r\n\r\nUsage:\r\n```shell\r\n$ python -m osxcollector.output_filters.virustotal.lookup_domains -h\r\nusage: lookup_domains.py [-h] [--input-file INPUT_FILE]\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  --input-file INPUT_FILE\r\n                        [OPTIONAL] Path to OSXCollector output to read.\r\n                        Defaults to stdin otherwise.\r\n```\r\n\r\n##### VirusTotal LookupHashesFilter\r\n`osxcollector.output_filters.virustotal.lookup_hashes.LookupHashesFilter` lookups hashes with the VirusTotal API. This basically finds anything VirusTotal knows about which is a huge time saver. There's pretty much no false positives here, but there's also no chance of detecting unknown stuff.\r\n\r\nRun it and see what was found:\r\n```shell\r\n$ python -m osxcollector.output_filters.virustotal.lookup_hashes -i FungalBuritto.json | \\\r\n    jq 'select(has(\"osxcollector_vthash\"))'\r\n```\r\n\r\nUsage:\r\n```shell\r\n$ python -m osxcollector.output_filters.virustotal.lookup_hashes -h\r\nusage: lookup_hashes.py [-h] [--input-file INPUT_FILE]\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  --input-file INPUT_FILE\r\n                        [OPTIONAL] Path to OSXCollector output to read.\r\n                        Defaults to stdin otherwise.\r\n```\r\n\r\n##### VirusTotal LookupURLsFilter\r\n`osxcollector.output_filters.virustotal.lookup_hashes.LookupURLsFilter` lookups URLs with the VirusTotal API. As this only looks up the reports, it may not find the reports for some unknown URLs.\r\n\r\nRun it and see what was found:\r\n```shell\r\n$ python -m osxcollector.output_filters.virustotal.lookup_urls -i WutheringLows.json | \\\r\n    jq 'select(has(\"osxcollector_vturl\"))'\r\n```\r\n\r\nUsage\r\n```shell\r\n$ python -m osxcollector.output_filters.virustotal.lookup_urls -h\r\nusage: lookup_urls.py [-h] [--input-file INPUT_FILE]\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  --input-file INPUT_FILE\r\n                        [OPTIONAL] Path to OSXCollector output to read.\r\n                        Defaults to stdin otherwise.\r\n```\r\n\r\n###### Maximum resources per request\r\nBoth VirusTotal LookupHashesFilter and LookupURLsFilter can save time by including in a single API request the reports for the multiple resources (hashes or URLs).\r\nAs the number of the maximum resources in a request depends on whether you are using a Public or Private API key it is configurable in `osxcollector.yaml` file in `virustotal` section:\r\n```yaml\r\nresources_per_req: 4\r\n```\r\n\r\n##### ShadowServer LookupHashesFilter\r\n`osxcollector.output_filters.shadowserver.lookup_hashes.LookupHashesFilter`\r\nlookups hashes with the ShadowServer bin-test API. This is sort of the opposite of a VirusTotal lookup and returns results when it sees the hashes of known good files. This helps raise confidence that a file is not malicious.\r\n\r\nRun it and see what was found:\r\n```shell\r\n$ python -m osxcollector.output_filters.shadowserver.lookup_hashes -i ArkashKobiashi.json | \\\r\n    jq 'select(has(\"osxcollector_shadowserver\"))'\r\n```\r\n\r\nUsage:\r\n```shell\r\n$ python -m osxcollector.output_filters.shadowserver.lookup_hashes -h\r\nusage: lookup_hashes.py [-h] [--input-file INPUT_FILE]\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  --input-file INPUT_FILE\r\n                        [OPTIONAL] Path to OSXCollector output to read.\r\n                        Defaults to stdin otherwise.\r\n```\r\n\r\n#### AnalyzeFilter - The One Filter to Rule Them All\r\n`osxcollector.output_filters.analyze.AnalyzeFilter` is Yelp's _one filter to rule them all_. It chains all the previous filters into one monster analysis. The results, enhanced with blacklist info, threat APIs, related files and domains, and even pretty browser history is written to a new output file.\r\n\r\nThen _Very Readable Output Bot_ takes over and prints out an easy-to-digest, human-readable, nearly-English summary of what it found. It's basically equivalent to running:\r\n```shell\r\n$ python -m osxcollector.output_filters.chrome.find_extensions.FindExtensionsFilter -i SlickApocalypse.json | \\\r\n    python -m osxcollector.output_filters.firefox.find_extensions.FindExtensionsFilter | \\\r\n    python -m osxcollector.output_filters.find_domains | \\\r\n    python -m osxcollector.output_filters.shadowserver.lookup_hashes | \\\r\n    python -m osxcollector.output_filters.virustotal.lookup_hashes | \\\r\n    python -m osxcollector.output_filters.find_blacklisted | \\\r\n    python -m osxcollector.output_filters.related_files | \\\r\n    python -m osxcollector.output_filters.opendns.related_domains | \\\r\n    python -m osxcollector.output_filters.opendns.lookup_domains | \\\r\n    python -m osxcollector.output_filters.virustotal.lookup_domains | \\\r\n    python -m osxcollector.output_filters.chrome_history | \\\r\n    python -m osxcollector.output_filters.firefox_history | \\\r\n    tee analyze_SlickApocalypse.json | \\\r\n    jq 'select(false == has(\"osxcollector_shadowserver\")) |\r\n        select(has(\"osxcollector_vthash\") or\r\n               has(\"osxcollector_vtdomain\") or\r\n               has(\"osxcollector_opendns\") or\r\n               has(\"osxcollector_blacklist\") or\r\n               has(\"osxcollector_related\"))'\r\n```\r\nand then letting a wise-cracking analyst explain the results to you. The _Very Readable Output Bot_ even suggests hashes and domains to add to blacklists.\r\n\r\nThis thing is the real deal and our analysts don't even look at OSXCollector output until after they've run the `AnalyzeFilter`.\r\n\r\nRun it as:\r\n```shell\r\n$ python -m osxcollector.output_filters.analyze -i FullMonty.json\r\n```\r\n\r\nUsage:\r\n```shell\r\n$ python -m osxcollector.output_filters.analyze -h\r\nusage: analyze.py [-f FILE_TERMS] [-d INITIAL_DOMAINS] [-i INITIAL_IPS]\r\n                  [--related-domains-generations GENERATIONS] [-h] [--readout]\r\n                  [--no-opendns] [--no-virustotal] [--no-shadowserver] [-M]\r\n                  [--show-signature-chain] [--show-browser-ext]\r\n                  [--input-file INPUT_FILE]\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  --input-file INPUT_FILE\r\n                        [OPTIONAL] Path to OSXCollector output to read.\r\n                        Defaults to stdin otherwise.\r\n\r\nRelatedFilesFilter:\r\n  -f FILE_TERMS, --file-term FILE_TERMS\r\n                        [OPTIONAL] Suspicious terms to use in pivoting through\r\n                        file names. May be specified more than once.\r\n\r\nopendns.RelatedDomainsFilter:\r\n  -d INITIAL_DOMAINS, --domain INITIAL_DOMAINS\r\n                        [OPTIONAL] Suspicious domains to use in pivoting. May\r\n                        be specified more than once.\r\n  -i INITIAL_IPS, --ip INITIAL_IPS\r\n                        [OPTIONAL] Suspicious IP to use in pivoting. May be\r\n                        specified more than once.\r\n  --related-domains-generations GENERATIONS\r\n                        [OPTIONAL] How many generations of related domains to\r\n                        lookup with OpenDNS\r\n\r\nAnalyzeFilter:\r\n  --readout             [OPTIONAL] Skip the analysis and just output really\r\n                        readable analysis\r\n  --no-opendns          [OPTIONAL] Don\\'t run OpenDNS filters\r\n  --no-virustotal       [OPTIONAL] Don\\'t run VirusTotal filters\r\n  --no-shadowserver     [OPTIONAL] Don\\'t run ShadowServer filters\r\n  -M, --monochrome      [OPTIONAL] Output monochrome analysis\r\n  --show-signature-chain\r\n                        [OPTIONAL] Output unsigned startup items and kexts.\r\n  --show-browser-ext    [OPTIONAL] Output the list of installed browser\r\n                        extensions.\r\n```\r\n\r\n## Contributing to OSXCollector\r\nWe encourage you to extend the functionality of OSXCollector to suit your needs.\r\n\r\n#### Testing OSXCollector\r\nA collection of tests for osxcollector is provided under the `tests` directory. In order to run these tests you must install [tox](https://pypi.python.org/pypi/tox):\r\n```shell\r\n$ sudo pip install tox\r\n```\r\n\r\nTo run this suit of tests, `cd` into `osxcollector` and enter:\r\n```shell\r\n$ make test\r\n```\r\n\r\n#### Development Tips\r\nThe functionality of OSXCollector is stored in a single file: `osxcollector.py`. The collector should run on a naked install of OS X without any additional packages or dependencies.\r\n\r\nEnsure that all of the OSXCollector tests pass before editing the source code. You can run the tests using: `make test`\r\n\r\nAfter making changes to the source code, run `make test` again to verify that your changes did not break any of the tests.\r\n\r\n## License\r\nThis work is licensed under the GNU General Public License and a derivation of [https://github.com/jipegit/OSXAuditor](https://github.com/jipegit/OSXAuditor)\r\n\r\n## Resources\r\nWant to learn more about OS X forensics?\r\n* [Sarah Edward's mac4n6.com](http://www.mac4n6.com/) - The best presentations on Mac forensics.\r\n\r\nA couple of other interesting tools:\r\n* [KnockKnock](https://github.com/synack/knockknock) - KnockKnock is a command line python script that displays persistent OS X binaries that are set to execute automatically at each boot.\r\n* [Grr](https://github.com/google/grr) - Google Rapid Response: remote live forensics for incident response\r\n* [osquery](https://github.com/facebook/osquery) - SQL powered operating system instrumentation, monitoring, and analytics\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}