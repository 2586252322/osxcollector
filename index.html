<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Osxcollector : A forensic evidence collection &amp; analysis toolkit for OSX">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Osxcollector</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/Yelp/osxcollector">View on GitHub</a>

          <h1 id="project_title">Osxcollector</h1>
          <h2 id="project_tagline">A forensic evidence collection &amp; analysis toolkit for OSX</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/Yelp/osxcollector/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/Yelp/osxcollector/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p><a href="https://travis-ci.org/Yelp/osxcollector"><img src="https://travis-ci.org/Yelp/osxcollector.svg" alt="Build Status"></a></p>

<h1>
<a id="osxcollector-manual" class="anchor" href="#osxcollector-manual" aria-hidden="true"><span class="octicon octicon-link"></span></a>OSXCollector Manual</h1>

<p>OSXCollector is a forensic evidence collection &amp; analysis toolkit for OSX.</p>

<h4>
<a id="forensic-collection" class="anchor" href="#forensic-collection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Forensic Collection</h4>

<p>The collection script runs on a potentially infected machine and outputs a JSON file that describes the target machine. OSXCollector gathers information from plists, SQLite databases and the local file system.</p>

<h4>
<a id="forensic-analysis" class="anchor" href="#forensic-analysis" aria-hidden="true"><span class="octicon octicon-link"></span></a>Forensic Analysis</h4>

<p>Armed with the forensic collection, an analyst can answer the question like:</p>

<ul>
<li><em>Is this machine infected?</em></li>
<li><em>How'd that malware get there?</em></li>
<li><em>How can I prevent and detect further infection?</em></li>
</ul>

<p>Yelp automates the analysis of most OSXCollector runs converting OSXCollector output into an easily readable and actionable summary of <em>just the suspicious stuff</em>.</p>

<h2>
<a id="performing-collection" class="anchor" href="#performing-collection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performing Collection</h2>

<p><code>osxcollector.py</code> is a single Python file that runs without any dependencies on a standard OSX machine. This makes it really easy to run collection on any machine - no fussing with brew, pip, config files, or environment variables. Just copy the single file onto the machine and run it.</p>

<p><code>sudo osxcollector.py</code> is all it takes.</p>

<div class="highlight highlight-shell"><pre>$ sudo osxcollector.py
Wrote 35394 lines.
Output <span class="pl-k">in</span> osxcollect-2014_12_21-08_49_39.tar.gz</pre></div>

<p>The JSON output of the collector, along with some helpful files like system logs, has been bundled into a .tar.gz for hand-off to an analyst.</p>

<p><code>osxcollector.py</code> also has a lot of useful options to change how collection works:</p>

<ul>
<li>
<p><code>-i INCIDENT_PREFIX</code>/<code>--id=INCIDENT_PREFIX</code>:
Sets an identifier which is used as the prefix of the output file. The default value is <code>osxcollect</code>.</p>

<div class="highlight highlight-shell"><pre>$ sudo osxcollector.py -i IncontinentSealord
Wrote 35394 lines.
Output <span class="pl-k">in</span> IncontinentSealord-2014_12_21-08_49_39.tar.gz</pre></div>

<p>Get creative with incident names, it makes it easier to laugh through the pain.</p>
</li>
<li>
<p><code>-p ROOTPATH</code>/<code>--path=ROOTPATH</code>:
Sets the path to the root of the filesystem to run collection on. The default value is <code>/</code>. This is great for running collection on the image of a disk.</p>

<div class="highlight highlight-shell"><pre>$ sudo osxcollector.py -p <span class="pl-s"><span class="pl-pds">'</span>/mnt/powned<span class="pl-pds">'</span></span></pre></div>
</li>
<li>
<p><code>-s SECTION</code>/<code>--section=SECTION</code>:
Runs only a portion of the full collection. Can be specified more than once. The full list of sections is:</p>

<ul>
<li><code>version</code></li>
<li><code>system_info</code></li>
<li><code>kext</code></li>
<li><code>startup</code></li>
<li><code>applications</code></li>
<li><code>quarantines</code></li>
<li><code>downloads</code></li>
<li><code>chrome</code></li>
<li><code>firefox</code></li>
<li><code>safari</code></li>
<li><code>accounts</code></li>
<li><code>mail</code></li>
<li><code>full_hash</code></li>
</ul>

<div class="highlight highlight-shell"><pre>$ sudo osxcollector.py -s <span class="pl-s"><span class="pl-pds">'</span>startup<span class="pl-pds">'</span></span> -s <span class="pl-s"><span class="pl-pds">'</span>downloads<span class="pl-pds">'</span></span></pre></div>
</li>
<li>
<p><code>-d</code>/<code>--debug</code>:
Enables verbose output and python breakpoints. If something is wrong with OSXCollector, try this.</p>

<div class="highlight highlight-shell"><pre>$ sudo osxcollector.py -d</pre></div>
</li>
</ul>

<h2>
<a id="details-of-collection" class="anchor" href="#details-of-collection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Details of Collection</h2>

<p>The collector outputs a <code>.tar.gz</code> containing all the collected artifacts. The archive contains a JSON file with the majority of information.  Additionally, a set of useful logs from the target system logs are included.</p>

<h4>
<a id="common-keys" class="anchor" href="#common-keys" aria-hidden="true"><span class="octicon octicon-link"></span></a>Common Keys</h4>

<h5>
<a id="every-record" class="anchor" href="#every-record" aria-hidden="true"><span class="octicon octicon-link"></span></a>Every Record</h5>

<p>Each line of the JSON file records 1 <em>piece of information</em>.  There are some common keys that appear in every JSON record:</p>

<ul>
<li>
<code>osxcollector_incident_id</code>: A unique ID shared by every record.</li>
<li>
<code>osxcollector_section</code>: The <em>section</em> or type of data this record holds.</li>
<li>
<code>osxcollector_subsection</code>: The <em>subsection</em> or more detailed descriptor of the type of data this record holds.</li>
</ul>

<h5>
<a id="file-records" class="anchor" href="#file-records" aria-hidden="true"><span class="octicon octicon-link"></span></a>File Records</h5>

<p>For records representing files there are a bunch of useful keys:</p>

<ul>
<li>
<code>ctime</code>: The file creation time.</li>
<li>
<code>mtime</code>: The file modified time.</li>
<li>
<code>file_path</code>: The absolute path to the file.</li>
<li>
<code>md5</code>: MD5 hash of the file contents.</li>
<li>
<code>sha1</code>: SHA1 hash of the file contents.</li>
<li>
<code>sha2</code>: SHA2 hash of the file contents.</li>
<li>
<code>signature_chain</code>: The common names of the certs in the file's signing chain</li>
</ul>

<p>For records representing downloaded files:</p>

<ul>
<li>
<code>xattr-wherefrom</code>: A list containing the source and referrer URLs for the downloaded file.</li>
<li>
<code>xattr-quarantines</code>: A string describing which application downloaded the file.</li>
</ul>

<h5>
<a id="sqlite-records" class="anchor" href="#sqlite-records" aria-hidden="true"><span class="octicon octicon-link"></span></a>SQLite Records</h5>

<p>For records representing a row of a SQLite database:</p>

<ul>
<li>
<code>osxcollector_table_name</code>: The table name the row comes from.</li>
<li>
<code>osxcollector_db_path</code>: The absolute path to the SQLite file.</li>
</ul>

<p>For records that represent data associated with a specific user:</p>

<ul>
<li>
<code>osxcollector_username</code>: The name of the user</li>
</ul>

<h4>
<a id="timestamps" class="anchor" href="#timestamps" aria-hidden="true"><span class="octicon octicon-link"></span></a>Timestamps</h4>

<p>OSXCollector attempts to convert timestamps to human readable date/time strings in the format <code>YYYY-mm-dd hh:MM:ss</code>. It uses heuristics to automatically identify various timestamps:</p>

<ul>
<li>seconds since epoch</li>
<li>milliseconds since epoch</li>
<li>seconds since 2001-01-01</li>
<li>seconds since 1601-01-01</li>
</ul>

<h4>
<a id="sections" class="anchor" href="#sections" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sections</h4>

<h5>
<a id="version-section" class="anchor" href="#version-section" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>version</code> section</h5>

<p>The current version of OSXCollector.</p>

<h5>
<a id="system_info-section" class="anchor" href="#system_info-section" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>system_info</code> section</h5>

<p>Collects basic information about the system:</p>

<ul>
<li>system name</li>
<li>node name</li>
<li>release</li>
<li>version</li>
<li>machine</li>
</ul>

<h5>
<a id="kext-section" class="anchor" href="#kext-section" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>kext</code> section</h5>

<p>Collects the Kernel extensions from:</p>

<ul>
<li><code>/System/Library/Extensions</code></li>
<li><code>/Library/Extensions</code></li>
</ul>

<h5>
<a id="startup-section" class="anchor" href="#startup-section" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>startup</code> section</h5>

<p>Collects information about the
<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man5/launchd.plist.5.html">LaunchAgents</a>,
LaunchDaemons, ScriptingAdditions,
<a href="https://developer.apple.com/library/mac/documentation/macosx/conceptual/bpsystemstartup/chapters/StartupItems.html">StartupItems</a>
and other login items from:</p>

<ul>
<li><code>/System/Library/LaunchAgents</code></li>
<li><code>/System/Library/LaunchDaemons</code></li>
<li><code>/Library/LaunchAgents</code></li>
<li><code>~/Library/LaunchAgents</code></li>
<li><code>/Library/LaunchDaemons</code></li>
<li><code>/System/Library/ScriptingAdditions</code></li>
<li><code>/Library/ScriptingAdditions</code></li>
<li><code>/System/Library/StartupItems</code></li>
<li><code>/Library/StartupItems</code></li>
<li><code>~/Library/Preferences/com.apple.loginitems.plist</code></li>
</ul>

<p>More information about the Max OS X startup can be found here:
<a href="http://www.malicious-streams.com/article/Mac_OSX_Startup.pdf">http://www.malicious-streams.com/article/Mac_OSX_Startup.pdf</a></p>

<h5>
<a id="applications-section" class="anchor" href="#applications-section" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>applications</code> section</h5>

<p>Hashes installed applications and gathers install history from:</p>

<ul>
<li><code>/Applications</code></li>
<li><code>~/Applications</code></li>
<li><code>/Library/Receipts/InstallHistory.plist</code></li>
</ul>

<h5>
<a id="quarantines-section" class="anchor" href="#quarantines-section" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>quarantines</code> section</h5>

<p>Quarantines are basically the info necessary to show the 'Are you sure you wanna run this?' when a user is trying to open a file downloaded from the Internet.
For some more details, checkout the Apple Support explanation of Quarantines:
<a href="http://support.apple.com/kb/HT3662">http://support.apple.com/kb/HT3662</a></p>

<p>This section collects also information from XProtect hash-based malware check
for quarantines files. The plist is at:
<code>/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/XProtect.plist</code></p>

<p>XProtect also add minimum versions for Internet Plugins. That plist is at:
<code>/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/XProtect.meta.plist</code></p>

<h5>
<a id="downloads-section" class="anchor" href="#downloads-section" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>downloads</code> section</h5>

<p>Hashes all users' downloaded files from:</p>

<ul>
<li><code>~/Downloads</code></li>
<li><code>~/Library/Mail Downloads</code></li>
<li><code>~/Library/Containers/com.apple.mail/Data/Library/Mail Downloads</code></li>
</ul>

<h5>
<a id="chrome-section" class="anchor" href="#chrome-section" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>chrome</code> section</h5>

<p>Collects following information from Google Chrome web browser:</p>

<ul>
<li>History</li>
<li>Archived History</li>
<li>Cookies</li>
<li>Login Data</li>
<li>Top Sites</li>
<li>Web Data</li>
</ul>

<p>This data is extracted from <code>~/Library/Application Support/Google/Chrome/Default</code></p>

<h5>
<a id="firefox-section" class="anchor" href="#firefox-section" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>firefox</code> section</h5>

<p>Collects information from the different SQLite databases in a Firefox profile:</p>

<ul>
<li>Cookies</li>
<li>Downloads</li>
<li>Form History</li>
<li>History</li>
<li>Signons</li>
<li>Permissions</li>
<li>Addons</li>
<li>Extension</li>
<li>Content Preferences</li>
<li>Health Report</li>
<li>Webapps Store</li>
</ul>

<p>This information is extracted from <code>~/Library/Application Support/Firefox/Profiles</code></p>

<p>For more details about Firefox profile folder see
<a href="http://kb.mozillazine.org/Profile_folder_-_Firefox">http://kb.mozillazine.org/Profile_folder_-_Firefox</a></p>

<h5>
<a id="safari-section" class="anchor" href="#safari-section" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>safari</code> section</h5>

<p>Collects information from the different plist and SQLite databases in a Safari
profile:</p>

<ul>
<li>Downloads</li>
<li>History</li>
<li>Databases</li>
<li>Local Storage</li>
</ul>

<h5>
<a id="accounts-section" class="anchor" href="#accounts-section" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>accounts</code> section</h5>

<p>Collects information about users' accounts:</p>

<ul>
<li>system admins: <code>/private/var/db/dslocal/nodes/Default/groups/admin.plist</code>
</li>
<li>system users: <code>/private/var/db/dslocal/nodes/Default/users</code>
</li>
<li>social accounts: <code>~/Library/Accounts/Accounts3.sqlite</code>
</li>
<li>users' recent items: <code>~/Library/Preferences/com.apple.recentitems.plist</code>
</li>
</ul>

<h5>
<a id="mail-section" class="anchor" href="#mail-section" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>mail</code> section</h5>

<p>Hashes files in the mail app directories:</p>

<ul>
<li><code>~/Library/Mail</code></li>
<li><code>~/Library/Mail Downloads</code></li>
</ul>

<h5>
<a id="full_hash-section" class="anchor" href="#full_hash-section" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>full_hash</code> section</h5>

<p>Hashes all the files on disk. All of 'em. This does not run by default. It must be triggered with:</p>

<div class="highlight highlight-shell"><pre>$ sudo osxcollector.py -s full_hash</pre></div>

<h2>
<a id="basic-manual-analysis" class="anchor" href="#basic-manual-analysis" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basic Manual Analysis</h2>

<p>Forensic analysis is a bit of art and a bit of science. Every analyst will see a bit of a different story when reading the output from OSXCollector. That's part of what makes analysis fun.</p>

<p>Generally, collection is performed on a target machine because something is hinky: anti-virus found a file it doesn't like, deep packet inspect observed a callout, endpoint monitoring noticed a new startup item. The details of this initial alert - a file path, a timestamp, a hash, a domain, an IP, etc. - that's enough to get going.</p>

<h4>
<a id="timestamps-1" class="anchor" href="#timestamps-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Timestamps</h4>

<p>Simply greping a few minutes before and after a timestamp works great:</p>

<div class="highlight highlight-shell"><pre>$ cat INCIDENT32.json <span class="pl-k">|</span> grep <span class="pl-s"><span class="pl-pds">'</span>2014-01-01 11:3[2-8]<span class="pl-pds">'</span></span></pre></div>

<h4>
<a id="browser-history" class="anchor" href="#browser-history" aria-hidden="true"><span class="octicon octicon-link"></span></a>Browser History</h4>

<p>It's in there. A tool like <a href="http://stedolan.github.io/jq/">jq</a> can be very helpful to do some fancy output:</p>

<div class="highlight highlight-shell"><pre>$ cat INCIDENT32.json <span class="pl-k">|</span> grep <span class="pl-s"><span class="pl-pds">'</span>2014-01-01 11:3[2-8]<span class="pl-pds">'</span></span> <span class="pl-k">|</span> jq <span class="pl-s"><span class="pl-pds">'</span>select(has("url"))|.url<span class="pl-pds">'</span></span></pre></div>

<h4>
<a id="a-single-user" class="anchor" href="#a-single-user" aria-hidden="true"><span class="octicon octicon-link"></span></a>A Single User</h4>

<div class="highlight highlight-shell"><pre>$ cat INCIDENT32.json <span class="pl-k">|</span> jq <span class="pl-s"><span class="pl-pds">'</span>select(.osxcollector_username=="ivanlei")|.<span class="pl-pds">'</span></span></pre></div>

<h2>
<a id="automated-analysis" class="anchor" href="#automated-analysis" aria-hidden="true"><span class="octicon octicon-link"></span></a>Automated Analysis</h2>

<p>The <code>osxcollector.output_filters</code> package contains filters that process and transform the output of OSXCollector. The goal of filters is to make it easy to analyze OSXCollector output.</p>

<p>Each filter has a single purpose. They do one thing and they do it right.</p>

<h4>
<a id="running-filters-in-a-virtualenv" class="anchor" href="#running-filters-in-a-virtualenv" aria-hidden="true"><span class="octicon octicon-link"></span></a>Running Filters in a VirtualEnv</h4>

<p>Unlike <code>osxcollector.py</code> filters have dependencies that aren't already installed on a new Mac. The best solution for ensure dependencies can be found is to use virtualenv.</p>

<p>To setup a virtualenv for the first time use:</p>

<div class="highlight highlight-shell"><pre>$ sudo pip install virtualenv
$ virtualenv --system-site-packages venv_osxcollector
$ <span class="pl-c1">source</span> ./venv_osxcollector/bin/activate
$ pip install -r ./requirements-dev.txt</pre></div>

<h4>
<a id="filter-configuration" class="anchor" href="#filter-configuration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Filter Configuration</h4>

<p>Many filters require configuration, like API keys or details on a blacklist. The configuration for filters is done in a YAML file. The file is named <code>osxcollector.yaml</code>. The filter will look for the config file in:</p>

<ul>
<li>The current directory.</li>
<li>The user's home directory</li>
<li>The path pointed to by the environment variable OSXCOLLECTOR_CONF</li>
</ul>

<p>A sample config is included. Make a copy and then modify if for yourself:</p>

<div class="highlight highlight-shell"><pre>$ cp osxcollector.yaml.example osxcollector.yaml
$ emacs osxcollector.yaml</pre></div>

<h4>
<a id="basic-filters" class="anchor" href="#basic-filters" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basic Filters</h4>

<p>Using combinations of these basic filters, an analyst can figure out a lot of what happened without expensive tools, without threat feeds or fancy APIs.</p>

<h5>
<a id="finddomainsfilter" class="anchor" href="#finddomainsfilter" aria-hidden="true"><span class="octicon octicon-link"></span></a>FindDomainsFilter</h5>

<p><code>osxcollector.output_filters.find_domains.FindDomainsFilter</code> attempts to find domain names in OSXCollector output. The domains are added to the line with the key <code>osxcollector_domains</code>.</p>

<p>FindDomainsFilter isn't too useful on it's own but it's super powerful when chained with filters like <code>FindBlacklistedFilter</code> and or <code>osxcollector.output_filters.virustotal.lookup_domains.LookupDomainsFilter</code>.</p>

<p>To run and see lines where domains have been added try:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.find_domains -i RomeoCredible.json <span class="pl-k">|</span> \
    jq <span class="pl-s"><span class="pl-pds">'</span>select(has("osxcollector_domains"))<span class="pl-pds">'</span></span></pre></div>

<p>Usage:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.find_domains -h
usage: find_domains.py [-h] [--input-file INPUT_FILE]

optional arguments:
  -h, --help            show this <span class="pl-c1">help</span> message and <span class="pl-c1">exit</span>
  --input-file INPUT_FILE
                        [OPTIONAL] Path to OSXCollector output to <span class="pl-c1">read</span>.
                        Defaults to stdin otherwise.</pre></div>

<h5>
<a id="findblacklistedfilter" class="anchor" href="#findblacklistedfilter" aria-hidden="true"><span class="octicon octicon-link"></span></a>FindBlacklistedFilter</h5>

<p><code>osxcollector.output_filters.find_blacklisted.FindBlacklistedFilter</code> reads a set of blacklists from the <code>osxcollector.yaml</code> and marks any lines with values on the blacklist. The BlacklistFilter is flexible and allows you to compare the OSXCollector output against multiple blacklists.</p>

<p>You <em>really should</em> create blacklists for domains, file hashes, file names, and any known hinky stuff.</p>

<p>Configuration Keys:</p>

<ul>
<li>
<code>blacklist_name</code>: [REQUIRED] the name of the blacklist.</li>
<li>
<code>blacklist_keys</code>: [REQUIRED] get the value of these keys and compare against the blacklist. These can be of the form <code>a.b</code> to look at <code>b</code> in <code>{"a": {"b": "foo"}}</code>
</li>
<li>
<code>blacklist_file_path</code>: [REQUIRED] path to a file with the actual values to blacklist</li>
<li>
<code>blacklist_is_regex</code>: [REQUIRED] should the values in the blacklist file be treated as regex</li>
<li>
<code>blacklist_is_domains</code>: [OPTIONAL] interpret values as domains and do some smart regex and subdomain stuff with them.</li>
</ul>

<p>If you want to find blacklisted domains, you will have to use the find_domains filter to pull the domains out first. To see lines matching a specific blacklist named <code>domains</code> try:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.find_domains -i RiddlerBelize.json <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.find_blacklisted <span class="pl-k">|</span> \
    jq <span class="pl-s"><span class="pl-pds">'</span>select(has("osxcollector_blacklist")) | \</span>
<span class="pl-s">        select(.osxcollector_blacklist | keys[] | contains("domains"))<span class="pl-pds">'</span></span></pre></div>

<p>Usage:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.find_blacklisted -h
usage: find_blacklisted.py [-h] [--input-file INPUT_FILE]

optional arguments:
  -h, --help            show this <span class="pl-c1">help</span> message and <span class="pl-c1">exit</span>
  --input-file INPUT_FILE
                        [OPTIONAL] Path to OSXCollector output to <span class="pl-c1">read</span>.
                        Defaults to stdin otherwise.</pre></div>

<h5>
<a id="relatedfilesfilter" class="anchor" href="#relatedfilesfilter" aria-hidden="true"><span class="octicon octicon-link"></span></a>RelatedFilesFilter</h5>

<p><code>osxcollector.output_filters.related_files.RelatedFilesFilter</code> takes an initial set of file paths, names, or terms. It breaks this input into individual file and directory names and then searches for these terms across the entire OSXCollector output. The filter is smart and ignores common terms like <code>bin</code> or <code>Library</code> as well as ignoring user names.</p>

<p>This filter is great for figuring out how <code>evil_invoice.pdf</code> landed up on a machine. It'll find browser history, quarantines, email messages, etc. related to a file.</p>

<p>To run and see related lines try:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.related_files -i CanisAsp.json -f <span class="pl-s"><span class="pl-pds">'</span>/foo/bar/baz<span class="pl-pds">'</span></span> -f <span class="pl-s"><span class="pl-pds">'</span>dingle<span class="pl-pds">'</span></span> <span class="pl-k">|</span> \
    jq <span class="pl-s"><span class="pl-pds">'</span>select(has("osxcollector_related")) | \</span>
<span class="pl-s">        select(.osxcollector_related | keys[] | contains("files"))<span class="pl-pds">'</span></span></pre></div>

<p>Usage:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.related_files -h
usage: related_files.py [-h] [-f FILE_TERMS] [--input-file INPUT_FILE]

optional arguments:
  -h, --help            show this <span class="pl-c1">help</span> message and <span class="pl-c1">exit</span>
  --input-file INPUT_FILE
                        [OPTIONAL] Path to OSXCollector output to <span class="pl-c1">read</span>.
                        Defaults to stdin otherwise.

RelatedFilesFilter:
  -f FILE_TERMS, --file-term FILE_TERMS
                        [OPTIONAL] Suspicious terms to use <span class="pl-k">in</span> pivoting through
                        file names. May be specified more than once.</pre></div>

<h5>
<a id="chromehistoryfilter" class="anchor" href="#chromehistoryfilter" aria-hidden="true"><span class="octicon octicon-link"></span></a>ChromeHistoryFilter</h5>

<p><code>osxcollector.output_filters.chrome.sort_history.SortHistoryFilter</code> builds a really nice Chrome browser history sorted in descending time order. This output is comparable to looking at the history tab in the browser but actually contains <em>more</em> info. The <code>core_transition</code> and <code>page_transition</code> keys explain whether the user got to the page by clicking a link, through a redirect, a hidden iframe, etc.</p>

<p>To run and see Chrome browser history:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.chrome.sort_history -i SirCray.json <span class="pl-k">|</span> \
    jq <span class="pl-s"><span class="pl-pds">'</span>select(.osxcollector_browser_history=="chrome")<span class="pl-pds">'</span></span></pre></div>

<p>This is great mixed with a grep in a certain time window, like maybe the 5 minutes before that hinky download happened.</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.chrome.sort_history -i SirCray.json <span class="pl-k">|</span> \
    jq -c <span class="pl-s"><span class="pl-pds">'</span>select(.osxcollector_browser_history=="chrome")<span class="pl-pds">'</span></span> <span class="pl-k">|</span> \
    egrep <span class="pl-s"><span class="pl-pds">'</span>2015-02-02 20:3[2-6]<span class="pl-pds">'</span></span></pre></div>

<p>Usage:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.chrome.sort_history -h
usage: sort_history.py [-h] [--input-file INPUT_FILE]

optional arguments:
  -h, --help            show this <span class="pl-c1">help</span> message and <span class="pl-c1">exit</span>
  --input-file INPUT_FILE
                        [OPTIONAL] Path to OSXCollector output to <span class="pl-c1">read</span>.
                        Defaults to stdin otherwise.</pre></div>

<h5>
<a id="firefoxhistoryfilter" class="anchor" href="#firefoxhistoryfilter" aria-hidden="true"><span class="octicon octicon-link"></span></a>FirefoxHistoryFilter</h5>

<p><code>osxcollector.output_filters.firefox.sort_history.SortHistoryFilter</code> builds a really nice Firefox browser history sorted in descending time order. It's a lot like the <code>ChromeHistoryFilter</code>.</p>

<p>To run and see Firefox browser history:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.firefox.sort_history -i CousingLobe.json <span class="pl-k">|</span> \
    jq <span class="pl-s"><span class="pl-pds">'</span>select(.osxcollector_browser_history=="firefox")<span class="pl-pds">'</span></span></pre></div>

<p>Usage:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.firefox.sort_history -h
usage: sort_history.py [-h] [--input-file INPUT_FILE]

optional arguments:
  -h, --help            show this <span class="pl-c1">help</span> message and <span class="pl-c1">exit</span>
  --input-file INPUT_FILE
                        [OPTIONAL] Path to OSXCollector output to <span class="pl-c1">read</span>.
                        Defaults to stdin otherwise.</pre></div>

<h5>
<a id="chromeextensionsfilter" class="anchor" href="#chromeextensionsfilter" aria-hidden="true"><span class="octicon octicon-link"></span></a>ChromeExtensionsFilter</h5>

<p><code>osxcollector.output_filters.chrome.find_extensions.FindExtensionsFilter</code> looks for extensions in the Chrome JSON files.</p>

<p>To run and see Chrome extensions:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.chrome.find_extensions -i MotherlyWolf.json <span class="pl-k">|</span> \
    jq <span class="pl-s"><span class="pl-pds">'</span>select(.osxcollector_section=="chrome" and</span>
<span class="pl-s">               .osxcollector_subsection=="extensions")<span class="pl-pds">'</span></span></pre></div>

<p>Usage:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.chrome.find_extensions -h
usage: find_extensions.py [-h] [--input-file INPUT_FILE]

optional arguments:
  -h, --help            show this <span class="pl-c1">help</span> message and <span class="pl-c1">exit</span>
  --input-file INPUT_FILE
                        [OPTIONAL] Path to OSXCollector output to <span class="pl-c1">read</span>.
                        Defaults to stdin otherwise.</pre></div>

<h5>
<a id="firefoxextensionsfilter" class="anchor" href="#firefoxextensionsfilter" aria-hidden="true"><span class="octicon octicon-link"></span></a>FirefoxExtensionsFilter</h5>

<p><code>osxcollector.output_filters.firefox.find_extensions.FindExtensionsFilter</code> looks for extensions in the Firefox JSON files.</p>

<p>To run and see Firefox extensions:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.firefox.find_extensions -i FlawlessPelican.json <span class="pl-k">|</span> \
    jq <span class="pl-s"><span class="pl-pds">'</span>select(.osxcollector_section=="firefox" and</span>
<span class="pl-s">               .osxcollector_subsection=="extensions")<span class="pl-pds">'</span></span></pre></div>

<p>Usage:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.firefox.find_extensions -h
usage: find_extensions.py [-h] [--input-file INPUT_FILE]

optional arguments:
  -h, --help            show this <span class="pl-c1">help</span> message and <span class="pl-c1">exit</span>
  --input-file INPUT_FILE
                        [OPTIONAL] Path to OSXCollector output to <span class="pl-c1">read</span>.
                        Defaults to stdin otherwise.</pre></div>

<h4>
<a id="threat-api-filters" class="anchor" href="#threat-api-filters" aria-hidden="true"><span class="octicon octicon-link"></span></a>Threat API Filters</h4>

<p>By taking the output of OSXCollector and looking up further info with OpenDNS and VirusTotal APIs, Yelp enhances the output with useful info. Some of these APIs aren't free but they are useful.</p>

<p>Using these filters as examples, it would be possible to integrate with additional free or premium threat APIs. <code>osxcollector.output_filters.base_filters.threat_feed.ThreatFeedFilter</code> has most of the plumbing for hooking up to arbitrary APIs.</p>

<h5>
<a id="opendns-relateddomainsfilter" class="anchor" href="#opendns-relateddomainsfilter" aria-hidden="true"><span class="octicon octicon-link"></span></a>OpenDNS RelatedDomainsFilter</h5>

<p><code>osxcollector.output_filters.opendns.related_domains.RelatedDomainsFilter</code> takes an initial set of domains and IPs and then looks up domains related to them with the OpenDNS Umbrella API.</p>

<p>Often an initial alert contains a domain or IP your analysts don't know anything about. However, by gathering the 2nd generation related domains, familiar <em>friends</em> might appear. When you're lucky, those related domains land up being the download source for some downloads you might have overlooked.</p>

<p>The filter will ignore domains if they are in the blacklist named <code>domain_whitelist</code>. This helps to reduce churn and false positives.</p>

<p>Run it as and see what it found:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.find_domains -i NotchCherry.json <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.opendns.related_domains \
           -d dismalhedgehog.com -d fantasticrabbit.org \
           -i 128.128.128.28 <span class="pl-k">|</span> \
    jq <span class="pl-s"><span class="pl-pds">'</span>select(has("osxcollector_related")) |</span>
<span class="pl-s">        select(.osxcollector_related | keys[] | contains("domains"))<span class="pl-pds">'</span></span></pre></div>

<p>The results will look something like:</p>

<pre><code>{
   'osxcollector_related': {
       'domains': {
           'domain_in_line.com': ['dismalhedgehog.com'],
           'another.com': ['128.128.128.28']
       }
    }
}
</code></pre>

<p>Usage:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.opendns.related_domains -h
usage: related_domains.py [-h] [-d INITIAL_DOMAINS] [-i INITIAL_IPS]
                          [--related-domains-generations GENERATIONS]
                          [--input-file INPUT_FILE]

optional arguments:
  -h, --help            show this <span class="pl-c1">help</span> message and <span class="pl-c1">exit</span>
  --input-file INPUT_FILE
                        [OPTIONAL] Path to OSXCollector output to <span class="pl-c1">read</span>.
                        Defaults to stdin otherwise.

opendns.RelatedDomainsFilter:
  -d INITIAL_DOMAINS, --domain INITIAL_DOMAINS
                        [OPTIONAL] Suspicious domains to use <span class="pl-k">in</span> pivoting. May
                        be specified more than once.
  -i INITIAL_IPS, --ip INITIAL_IPS
                        [OPTIONAL] Suspicious IP to use <span class="pl-k">in</span> pivoting. May be
                        specified more than once.
  --related-domains-generations GENERATIONS
                        [OPTIONAL] How many generations of related domains to
                        lookup with OpenDNS</pre></div>

<h5>
<a id="opendns-lookupdomainsfilter" class="anchor" href="#opendns-lookupdomainsfilter" aria-hidden="true"><span class="octicon octicon-link"></span></a>OpenDNS LookupDomainsFilter</h5>

<p><code>osxcollector.output_filters.opendns.lookup_domains.LookupDomainsFilter</code> lookups domain reputation and threat information with the OpenDNS Umbrella API. It adds information about <em>suspicious</em> domains to the output lines.</p>

<p>The filter uses a heuristic to determine what is <em>suspicious</em>. It can create false positives but usually a download from a domain marked as <em>suspicious</em> is a good lead.</p>

<p>Run it and see what was found:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.find_domains -i GladElegant.json <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.opendns.lookup_domains <span class="pl-k">|</span> \
    jq <span class="pl-s"><span class="pl-pds">'</span>select(has("osxcollector_opendns"))<span class="pl-pds">'</span></span></pre></div>

<p>Usage:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.opendns.lookup_domains -h
usage: lookup_domains.py [-h] [--input-file INPUT_FILE]

optional arguments:
  -h, --help            show this <span class="pl-c1">help</span> message and <span class="pl-c1">exit</span>
  --input-file INPUT_FILE
                        [OPTIONAL] Path to OSXCollector output to <span class="pl-c1">read</span>.
                        Defaults to stdin otherwise.</pre></div>

<h5>
<a id="virustotal-lookupdomainsfilter" class="anchor" href="#virustotal-lookupdomainsfilter" aria-hidden="true"><span class="octicon octicon-link"></span></a>VirusTotal LookupDomainsFilter</h5>

<p><code>osxcollector.output_filters.virustotal.lookup_domains.LookupDomainsFilter</code> lookups domain reputation and threat information with the VirusTotal API. It adds information about <em>suspicious</em> domains to the output lines. It's a lot like the OpenDNS filter of the same name.</p>

<p>The filter uses a heuristic to determine what is <em>suspicious</em>. It can create a lot of false positives but also provides good leads.</p>

<p>Run it and see what was found:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.find_domains -i PippinNightstar.json <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.virustotal.lookup_domains <span class="pl-k">|</span> \
    jq <span class="pl-s"><span class="pl-pds">'</span>select(has("osxcollector_vtdomain"))<span class="pl-pds">'</span></span></pre></div>

<p>Usage:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.virustotal.lookup_domains -h
usage: lookup_domains.py [-h] [--input-file INPUT_FILE]

optional arguments:
  -h, --help            show this <span class="pl-c1">help</span> message and <span class="pl-c1">exit</span>
  --input-file INPUT_FILE
                        [OPTIONAL] Path to OSXCollector output to <span class="pl-c1">read</span>.
                        Defaults to stdin otherwise.</pre></div>

<h5>
<a id="virustotal-lookuphashesfilter" class="anchor" href="#virustotal-lookuphashesfilter" aria-hidden="true"><span class="octicon octicon-link"></span></a>VirusTotal LookupHashesFilter</h5>

<p><code>osxcollector.output_filters.virustotal.lookup_hashes.LookupHashesFilter</code> lookups hashes with the VirusTotal API. This basically finds anything VirusTotal knows about which is a huge time saver. There's pretty much no false positives here, but there's also no chance of detecting unknown stuff.</p>

<p>Run it and see what was found:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.virustotal.lookup_hashes -i FungalBuritto.json <span class="pl-k">|</span> \
    jq <span class="pl-s"><span class="pl-pds">'</span>select(has("osxcollector_vthash"))<span class="pl-pds">'</span></span></pre></div>

<p>Usage:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.virustotal.lookup_hashes -h
usage: lookup_hashes.py [-h] [--input-file INPUT_FILE]

optional arguments:
  -h, --help            show this <span class="pl-c1">help</span> message and <span class="pl-c1">exit</span>
  --input-file INPUT_FILE
                        [OPTIONAL] Path to OSXCollector output to <span class="pl-c1">read</span>.
                        Defaults to stdin otherwise.</pre></div>

<h5>
<a id="virustotal-lookupurlsfilter" class="anchor" href="#virustotal-lookupurlsfilter" aria-hidden="true"><span class="octicon octicon-link"></span></a>VirusTotal LookupURLsFilter</h5>

<p><code>osxcollector.output_filters.virustotal.lookup_hashes.LookupURLsFilter</code> lookups URLs with the VirusTotal API. As this only looks up the reports, it may not find the reports for some unknown URLs.</p>

<p>Run it and see what was found:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.virustotal.lookup_urls -i WutheringLows.json <span class="pl-k">|</span> \
    jq <span class="pl-s"><span class="pl-pds">'</span>select(has("osxcollector_vturl"))<span class="pl-pds">'</span></span></pre></div>

<p>Usage</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.virustotal.lookup_urls -h
usage: lookup_urls.py [-h] [--input-file INPUT_FILE]

optional arguments:
  -h, --help            show this <span class="pl-c1">help</span> message and <span class="pl-c1">exit</span>
  --input-file INPUT_FILE
                        [OPTIONAL] Path to OSXCollector output to <span class="pl-c1">read</span>.
                        Defaults to stdin otherwise.</pre></div>

<h6>
<a id="maximum-resources-per-request" class="anchor" href="#maximum-resources-per-request" aria-hidden="true"><span class="octicon octicon-link"></span></a>Maximum resources per request</h6>

<p>Both VirusTotal LookupHashesFilter and LookupURLsFilter can save time by including in a single API request the reports for the multiple resources (hashes or URLs).
As the number of the maximum resources in a request depends on whether you are using a Public or Private API key it is configurable in <code>osxcollector.yaml</code> file in <code>virustotal</code> section:</p>

<div class="highlight highlight-yaml"><pre><span class="pl-c1"><span class="pl-ent">resources_per_req:</span> 4</span></pre></div>

<h5>
<a id="shadowserver-lookuphashesfilter" class="anchor" href="#shadowserver-lookuphashesfilter" aria-hidden="true"><span class="octicon octicon-link"></span></a>ShadowServer LookupHashesFilter</h5>

<p><code>osxcollector.output_filters.shadowserver.lookup_hashes.LookupHashesFilter</code>
lookups hashes with the ShadowServer bin-test API. This is sort of the opposite of a VirusTotal lookup and returns results when it sees the hashes of known good files. This helps raise confidence that a file is not malicious.</p>

<p>Run it and see what was found:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.shadowserver.lookup_hashes -i ArkashKobiashi.json <span class="pl-k">|</span> \
    jq <span class="pl-s"><span class="pl-pds">'</span>select(has("osxcollector_shadowserver"))<span class="pl-pds">'</span></span></pre></div>

<p>Usage:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.shadowserver.lookup_hashes -h
usage: lookup_hashes.py [-h] [--input-file INPUT_FILE]

optional arguments:
  -h, --help            show this <span class="pl-c1">help</span> message and <span class="pl-c1">exit</span>
  --input-file INPUT_FILE
                        [OPTIONAL] Path to OSXCollector output to <span class="pl-c1">read</span>.
                        Defaults to stdin otherwise.</pre></div>

<h4>
<a id="analyzefilter---the-one-filter-to-rule-them-all" class="anchor" href="#analyzefilter---the-one-filter-to-rule-them-all" aria-hidden="true"><span class="octicon octicon-link"></span></a>AnalyzeFilter - The One Filter to Rule Them All</h4>

<p><code>osxcollector.output_filters.analyze.AnalyzeFilter</code> is Yelp's <em>one filter to rule them all</em>. It chains all the previous filters into one monster analysis. The results, enhanced with blacklist info, threat APIs, related files and domains, and even pretty browser history is written to a new output file.</p>

<p>Then <em>Very Readable Output Bot</em> takes over and prints out an easy-to-digest, human-readable, nearly-English summary of what it found. It's basically equivalent to running:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.chrome.find_extensions.FindExtensionsFilter -i SlickApocalypse.json <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.firefox.find_extensions.FindExtensionsFilter <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.find_domains <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.shadowserver.lookup_hashes <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.virustotal.lookup_hashes <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.find_blacklisted <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.related_files <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.opendns.related_domains <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.opendns.lookup_domains <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.virustotal.lookup_domains <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.chrome_history <span class="pl-k">|</span> \
    python -m osxcollector.output_filters.firefox_history <span class="pl-k">|</span> \
    tee analyze_SlickApocalypse.json <span class="pl-k">|</span> \
    jq <span class="pl-s"><span class="pl-pds">'</span>select(false == has("osxcollector_shadowserver")) |</span>
<span class="pl-s">        select(has("osxcollector_vthash") or</span>
<span class="pl-s">               has("osxcollector_vtdomain") or</span>
<span class="pl-s">               has("osxcollector_opendns") or</span>
<span class="pl-s">               has("osxcollector_blacklist") or</span>
<span class="pl-s">               has("osxcollector_related"))<span class="pl-pds">'</span></span></pre></div>

<p>and then letting a wise-cracking analyst explain the results to you. The <em>Very Readable Output Bot</em> even suggests hashes and domains to add to blacklists.</p>

<p>This thing is the real deal and our analysts don't even look at OSXCollector output until after they've run the <code>AnalyzeFilter</code>.</p>

<p>Run it as:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.analyze -i FullMonty.json</pre></div>

<p>Usage:</p>

<div class="highlight highlight-shell"><pre>$ python -m osxcollector.output_filters.analyze -h
usage: analyze.py [-f FILE_TERMS] [-d INITIAL_DOMAINS] [-i INITIAL_IPS]
                  [--related-domains-generations GENERATIONS] [-h] [--readout]
                  [--no-opendns] [--no-virustotal] [--no-shadowserver] [-M]
                  [--show-signature-chain] [--show-browser-ext]
                  [--input-file INPUT_FILE]

optional arguments:
  -h, --help            show this <span class="pl-c1">help</span> message and <span class="pl-c1">exit</span>
  --input-file INPUT_FILE
                        [OPTIONAL] Path to OSXCollector output to <span class="pl-c1">read</span>.
                        Defaults to stdin otherwise.

RelatedFilesFilter:
  -f FILE_TERMS, --file-term FILE_TERMS
                        [OPTIONAL] Suspicious terms to use <span class="pl-k">in</span> pivoting through
                        file names. May be specified more than once.

opendns.RelatedDomainsFilter:
  -d INITIAL_DOMAINS, --domain INITIAL_DOMAINS
                        [OPTIONAL] Suspicious domains to use <span class="pl-k">in</span> pivoting. May
                        be specified more than once.
  -i INITIAL_IPS, --ip INITIAL_IPS
                        [OPTIONAL] Suspicious IP to use <span class="pl-k">in</span> pivoting. May be
                        specified more than once.
  --related-domains-generations GENERATIONS
                        [OPTIONAL] How many generations of related domains to
                        lookup with OpenDNS

AnalyzeFilter:
  --readout             [OPTIONAL] Skip the analysis and just output really
                        readable analysis
  --no-opendns          [OPTIONAL] Don<span class="pl-cce">\'</span>t run OpenDNS filters
  --no-virustotal       [OPTIONAL] Don<span class="pl-cce">\'</span>t run VirusTotal filters
  --no-shadowserver     [OPTIONAL] Don<span class="pl-cce">\'</span>t run ShadowServer filters
  -M, --monochrome      [OPTIONAL] Output monochrome analysis
  --show-signature-chain
                        [OPTIONAL] Output unsigned startup items and kexts.
  --show-browser-ext    [OPTIONAL] Output the list of installed browser
                        extensions.</pre></div>

<h2>
<a id="contributing-to-osxcollector" class="anchor" href="#contributing-to-osxcollector" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contributing to OSXCollector</h2>

<p>We encourage you to extend the functionality of OSXCollector to suit your needs.</p>

<h4>
<a id="testing-osxcollector" class="anchor" href="#testing-osxcollector" aria-hidden="true"><span class="octicon octicon-link"></span></a>Testing OSXCollector</h4>

<p>A collection of tests for osxcollector is provided under the <code>tests</code> directory. In order to run these tests you must install <a href="https://pypi.python.org/pypi/tox">tox</a>:</p>

<div class="highlight highlight-shell"><pre>$ sudo pip install tox</pre></div>

<p>To run this suit of tests, <code>cd</code> into <code>osxcollector</code> and enter:</p>

<div class="highlight highlight-shell"><pre>$ make <span class="pl-c1">test</span></pre></div>

<h4>
<a id="development-tips" class="anchor" href="#development-tips" aria-hidden="true"><span class="octicon octicon-link"></span></a>Development Tips</h4>

<p>The functionality of OSXCollector is stored in a single file: <code>osxcollector.py</code>. The collector should run on a naked install of OS X without any additional packages or dependencies.</p>

<p>Ensure that all of the OSXCollector tests pass before editing the source code. You can run the tests using: <code>make test</code></p>

<p>After making changes to the source code, run <code>make test</code> again to verify that your changes did not break any of the tests.</p>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h2>

<p>This work is licensed under the GNU General Public License and a derivation of <a href="https://github.com/jipegit/OSXAuditor">https://github.com/jipegit/OSXAuditor</a></p>

<h2>
<a id="resources" class="anchor" href="#resources" aria-hidden="true"><span class="octicon octicon-link"></span></a>Resources</h2>

<p>Want to learn more about OS X forensics?</p>

<ul>
<li>
<a href="http://www.mac4n6.com/">Sarah Edward's mac4n6.com</a> - The best presentations on Mac forensics.</li>
</ul>

<p>A couple of other interesting tools:</p>

<ul>
<li>
<a href="https://github.com/synack/knockknock">KnockKnock</a> - KnockKnock is a command line python script that displays persistent OS X binaries that are set to execute automatically at each boot.</li>
<li>
<a href="https://github.com/google/grr">Grr</a> - Google Rapid Response: remote live forensics for incident response</li>
<li>
<a href="https://github.com/facebook/osquery">osquery</a> - SQL powered operating system instrumentation, monitoring, and analytics</li>
</ul>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Osxcollector maintained by <a href="https://github.com/Yelp">Yelp</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
